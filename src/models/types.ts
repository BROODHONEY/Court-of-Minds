/**
 * Court of Minds - Data Models and Type Definitions
 * 
 * This file contains all TypeScript interfaces and types for the AI Court System.
 * These types define the structure of data flowing through the deliberation pipeline.
 */

// ============================================================================
// Core Entity Types
// ============================================================================

/**
 * Represents a user-submitted query to be processed by the system
 */
export interface Query {
  /** Unique identifier for the query */
  id: string;
  /** The actual question or problem text */
  text: string;
  /** ID of the user who submitted the query */
  userId: string;
  /** Optional array of specific model IDs to use (for multi-model mode) */
  selectedModels?: string[];
  /** When the query was submitted */
  timestamp: Date;
}

/**
 * Response generated by a single AI model
 */
export interface ModelResponse {
  /** ID of the model that generated this response */
  modelId: string;
  /** The response text content */
  text: string;
  /** Number of tokens used in the response */
  tokens: number;
  /** Response generation time in milliseconds */
  latency: number;
  /** When the response was generated */
  timestamp: Date;
}

/**
 * Query execution mode
 */
export type QueryMode = 'single' | 'multi';

/**
 * Session status throughout the deliberation lifecycle
 */
export type SessionStatus = 
  | 'collecting'   // Collecting initial responses from models
  | 'analyzing'    // Analyzing responses for similarities/differences
  | 'debating'     // Models are debating their approaches
  | 'consensus'    // Building consensus on final solution
  | 'completed'    // Session successfully completed
  | 'failed';      // Session failed due to errors

/**
 * Complete session record tracking an entire deliberation cycle
 */
export interface Session {
  /** Unique session identifier */
  id: string;
  /** ID of the user who initiated the session */
  userId: string;
  /** The original query */
  query: Query;
  /** Execution mode (single or multi-model) */
  mode: QueryMode;
  /** Current status of the session */
  status: SessionStatus;
  /** Collected model responses (after collection phase) */
  responses?: ModelResponse[];
  /** Analysis report (after analysis phase) */
  analysis?: AnalysisReport;
  /** Debate results (after debate phase) */
  debate?: DebateResult;
  /** Consensus results (after consensus phase) */
  consensus?: ConsensusResult;
  /** Any errors that occurred during the session */
  errors?: ModelFailure[];
  /** When the session was created */
  createdAt: Date;
  /** When the session was last updated */
  updatedAt: Date;
  /** When the session completed (if completed) */
  completedAt?: Date;
}

// ============================================================================
// Model Configuration Types
// ============================================================================

/**
 * Configuration for an AI model
 */
export interface ModelConfig {
  /** Unique identifier for the model */
  id: string;
  /** Provider name (openai, anthropic, google, custom) */
  provider: 'openai' | 'anthropic' | 'google' | 'groq' | 'huggingface' | 'custom';
  /** API key for authentication */
  apiKey: string;
  /** Specific model name (e.g., gpt-4, claude-3-opus) */
  modelName: string;
  /** Whether the model is enabled for use */
  enabled: boolean;
  /** Maximum tokens for responses */
  maxTokens: number;
  /** Temperature setting for response generation */
  temperature: number;
  /** Timeout in seconds for model responses */
  timeout: number;
}

/**
 * Represents a configured AI model instance
 */
export interface Model {
  /** Unique identifier */
  id: string;
  /** Provider name */
  provider: string;
  /** Display name */
  name: string;
  /** Whether the model is currently enabled */
  enabled: boolean;
  /** Adapter instance for communicating with the model */
  adapter: ModelAdapter;
}

/**
 * Information about a model's capabilities
 */
export interface ModelInfo {
  /** Provider name */
  provider: string;
  /** Model name */
  modelName: string;
  /** List of model capabilities */
  capabilities: string[];
}

/**
 * Health status of a model
 */
export interface HealthStatus {
  /** Whether the model is healthy and responsive */
  healthy: boolean;
  /** Response time in milliseconds (if healthy) */
  responseTime?: number;
  /** Error message (if unhealthy) */
  error?: string;
  /** When the health check was performed */
  timestamp: Date;
}

// ============================================================================
// Context and Adapter Types
// ============================================================================

/**
 * Context provided to models during different phases
 */
export interface Context {
  /** Previous responses from other models (for debate/consensus) */
  previousResponses?: ModelResponse[];
  /** Analysis report (for debate phase) */
  analysisReport?: AnalysisReport;
  /** Debate history (for consensus phase) */
  debateHistory?: DebateRound[];
}

/**
 * Interface that all model adapters must implement
 */
export interface ModelAdapter {
  /**
   * Generate a response from the model
   * @param prompt The prompt to send to the model
   * @param context Optional context from previous phases
   * @returns The model's response
   */
  generateResponse(prompt: string, context?: Context): Promise<ModelResponse>;
  
  /**
   * Get information about the model
   * @returns Model information
   */
  getModelInfo(): ModelInfo;
}

// ============================================================================
// Analysis Types
// ============================================================================

/**
 * A common theme identified across multiple model responses
 */
export interface Theme {
  /** Description of the theme */
  description: string;
  /** IDs of models that support this theme */
  supportingModels: string[];
  /** Confidence score (0-1) for this theme */
  confidence: number;
}

/**
 * A unique approach taken by a specific model
 */
export interface Approach {
  /** ID of the model using this approach */
  modelId: string;
  /** Description of the approach */
  description: string;
  /** Methodology used */
  methodology: string;
}

/**
 * Type of difference between model responses
 */
export type DifferenceType = 'methodology' | 'conclusion' | 'assumptions' | 'reasoning';

/**
 * A difference identified between model responses
 */
export interface Difference {
  /** Type of difference */
  type: DifferenceType;
  /** Description of the difference */
  description: string;
  /** IDs of models involved in this difference */
  involvedModels: string[];
}

/**
 * Complete analysis report comparing model responses
 */
export interface AnalysisReport {
  /** Common themes across all responses */
  commonThemes: Theme[];
  /** Unique approaches from individual models */
  uniqueApproaches: Approach[];
  /** Identified differences between responses */
  differences: Difference[];
  /** Natural language summary of the analysis */
  summary: string;
  /** When the analysis was completed */
  timestamp: Date;
}

// ============================================================================
// Debate Types
// ============================================================================

/**
 * A single model's contribution to a debate round
 */
export interface DebateExchange {
  /** ID of the model making this exchange */
  modelId: string;
  /** Critique of other models' responses */
  critique: string;
  /** Defense of the model's own position */
  defense: string;
  /** Optional revised position based on debate */
  revisedPosition?: string;
  /** When this exchange was made */
  timestamp: Date;
}

/**
 * A complete round of debate
 */
export interface DebateRound {
  /** Round number (1-based) */
  roundNumber: number;
  /** All exchanges in this round */
  exchanges: DebateExchange[];
  /** Disagreement level after this round (0-1, lower is better) */
  disagreementLevel: number;
}

/**
 * Complete results from the debate phase
 */
export interface DebateResult {
  /** All debate rounds conducted */
  rounds: DebateRound[];
  /** Final convergence score (0-1, higher is better) */
  convergenceScore: number;
  /** Total duration of debate phase in milliseconds */
  duration: number;
}

// ============================================================================
// Consensus Types
// ============================================================================

/**
 * An insight incorporated into the final solution
 */
export interface Insight {
  /** Source model ID or "synthesized" */
  source: string;
  /** Description of the insight */
  description: string;
  /** Whether this insight was incorporated into the final solution */
  incorporated: boolean;
}

/**
 * A proposed or final solution
 */
export interface Solution {
  /** The solution text */
  text: string;
  /** IDs of models supporting this solution */
  supportingModels: string[];
  /** Insights incorporated into this solution */
  incorporatedInsights: Insight[];
  /** Confidence score (0-1) */
  confidence: number;
}

/**
 * Results from the consensus building phase
 */
export interface ConsensusResult {
  /** The final agreed-upon solution */
  finalSolution: Solution;
  /** Agreement level among models (0-1) */
  agreementLevel: number;
  /** Rationale explaining how consensus was reached */
  rationale: string;
  /** Duration of consensus phase in milliseconds */
  duration: number;
}

// ============================================================================
// Error and Result Types
// ============================================================================

/**
 * Record of a model failure
 */
export interface ModelFailure {
  /** ID of the model that failed */
  modelId: string;
  /** Error message */
  error: string;
  /** When the failure occurred */
  timestamp: Date;
}

/**
 * Result from collecting responses from multiple models
 */
export interface CollectionResult {
  /** Successfully collected responses */
  responses: ModelResponse[];
  /** Any failures that occurred */
  failures: ModelFailure[];
  /** Total duration of collection phase in milliseconds */
  duration: number;
}

/**
 * Filters for querying session history
 */
export interface SessionFilters {
  /** Filter by sessions after this date */
  startDate?: Date;
  /** Filter by sessions before this date */
  endDate?: Date;
  /** Filter by query mode */
  mode?: QueryMode;
  /** Filter by session status */
  status?: SessionStatus;
}

/**
 * Update data for modifying a session
 */
export interface SessionUpdate {
  /** Updated status */
  status?: SessionStatus;
  /** Add responses */
  responses?: ModelResponse[];
  /** Set analysis report */
  analysis?: AnalysisReport;
  /** Set debate result */
  debate?: DebateResult;
  /** Set consensus result */
  consensus?: ConsensusResult;
  /** Add errors */
  errors?: ModelFailure[];
  /** Set completion time */
  completedAt?: Date;
}

/**
 * Result returned to the user after session completion
 */
export interface SessionResult {
  /** The session ID */
  sessionId: string;
  /** The final solution (for multi-model) or direct response (for single-model) */
  result: string;
  /** Complete session data */
  session: Session;
}

/**
 * Error response format
 */
export interface ErrorResponse {
  /** Error code */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Additional error details */
  details?: Record<string, any>;
  /** When the error occurred */
  timestamp: Date;
  /** Associated session ID (if applicable) */
  sessionId?: string;
}
